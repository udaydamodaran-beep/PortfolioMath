# Instruction: "Given to you are the returns generated by two stocks A and B over the last 6 years 2019-2024"

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Page layout
st.set_page_config(page_title="Portfolio Math — Multiple B datasets", layout="centered")

st.title("Portfolio Math Demo")
st.markdown('**"Given to you are the returns generated by two stocks A and B over the last 6 years 2019-2024"**')

# Constant A returns (same for all datasets)
A_returns = np.array([0.06, 0.08, 0.05, 0.10, 0.25, 0.07])

# Three B variants (as decimals)
datasets = {
    "B set 1 — [2%, 4%, 1%, 25%, 40%, 3%]": np.array([0.02, 0.04, 0.01, 0.25, 0.40, 0.03]),
    "B set 2 — [25%, 3%, 40%, 2%, 1%, 4%]": np.array([0.25, 0.03, 0.40, 0.02, 0.01, 0.04]),
    "B set 3 — [2%, 25%, 8%, 40%, 8%, 0%]": np.array([0.02, 0.25, 0.08, 0.40, 0.08, 0.00]),
}

# Dropdown to pick dataset
choice = st.selectbox("Choose Stock B return series", list(datasets.keys()))
B_returns = datasets[choice]

# Build dataframe for display
years = [2019, 2020, 2021, 2022, 2023, 2024]
df = pd.DataFrame({
    "Year": years,
    "Stock A": A_returns,
    "Stock B": B_returns
})

st.subheader("Historical Returns (decimals)")
st.dataframe(df.set_index("Year"), use_container_width=True)

st.markdown("""
**Prompt to user:**  
Assuming the stocks’ behavior in the next year to be driven by the past return–risk behavior, how much of your money will you put in A and how much in B?  
Your answer should be in decimals. For example, if you plan to divide your money equally between the two stocks your response to A should be 0.5 and to B should be 0.5.  
**Note: the weights must add up to 1.**
""")

# Slider for weight in A (B = 1 - A)
wA = st.slider("Proportion of your money in A", min_value=0.0, max_value=1.0, value=0.5, step=0.01)
wB = 1.0 - wA
st.write(f"Proportion of your money in B: **{wB:.2f}**")

# Convert to numpy returns matrix (n x 2)
rets = np.column_stack((A_returns, B_returns))  # shape (6,2)

# Compute sample mean and covariance (ddof=1)
mu = rets.mean(axis=0)                 # vector length 2
Sigma = np.cov(rets, rowvar=False, ddof=1)

# Portfolio stats
weights = np.array([wA, wB])
exp_return = float(weights @ mu)
port_var = float(weights @ Sigma @ weights)
port_std = np.sqrt(port_var)

st.subheader("Portfolio Results")
col1, col2 = st.columns(2)
col1.metric("Expected Return", f"{exp_return:.2%}")
col2.metric("Standard Deviation (Risk)", f"{port_std:.2%}")

# Feasible frontier (grid over weights)
wA_grid = np.linspace(0, 1, 201)
wB_grid = 1.0 - wA_grid
frontier_returns = wA_grid * mu[0] + wB_grid * mu[1]
frontier_risks = np.sqrt(
    (wA_grid**2) * Sigma[0, 0]
    + (wB_grid**2) * Sigma[1, 1]
    + 2 * wA_grid * wB_grid * Sigma[0, 1]
)

# Plotting - create a fresh figure each time (avoid plt state)
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(frontier_risks, frontier_returns, label="Feasible Frontier", linewidth=2)
ax.scatter(port_std, exp_return, s=120, marker="o", color="red", label=f"Your Portfolio (wA={wA:.2f})")
ax.set_xlabel("Portfolio Risk (Std. Deviation)")
ax.set_ylabel("Portfolio Expected Return")
ax.set_title("Two-Asset Feasible Frontier")
ax.grid(True)
ax.legend()

# Show the figure and then close it to avoid state/back-end issues
st.pyplot(fig)
plt.close(fig)

# Optional: show numeric mu and Sigma for transparency
with st.expander("Show mean returns and covariance matrix"):
    st.write("Mean returns (A, B):", np.round(mu, 4))
    cov_df = pd.DataFrame(Sigma, index=["A", "B"], columns=["A", "B"])
    st.write("Sample covariance matrix:")
    st.dataframe(cov_df.style.format("{:.6f}"))
